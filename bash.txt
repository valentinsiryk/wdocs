====
BASH
====


http://talk.jpnc.info/bash_lfnw_2017.pdf


Add zeros before number::

    VAR=15
    echo "$(seq -f %03g $VAR $VAR)"
    # 015


BASH if grep ixists statement::

    if grep --quiet 'text' /path/to/file; then
      echo exists
    else
      echo not found
    fi


Get path to script which run::

    SCRIPT_PATH="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"


Bash get last line from a variable::

    echo "${VAR##*$'\n'}"


Is file exist::

    if [ ! -f /tmp/foo.txt ]; then
        echo "File not found!"
    fi


Functions on BASH::

    #!/bin/sh

    # this will fail because foo has not been declared yet.
    myFunction parameter_1 parameter_2

    [function] myFunction() {
        echo "Parameters: $1 $2"
    }

    # this will work
    myFunction parameter_1 parameter_2


Do while with iterator::

    COUNT=0

    while [ $COUNT -lt 10 ]
    do
            (( COUNT++ ))
            echo $COUNT
    done


Boolean in BASH::

    VAR=true

    if [ "$VAR" = true ] ; then
        echo 'true'
    fi


Check if a variable is set::

    if [ -z ${var+x} ]; then
        echo "var is unset"
    else
        echo "var is set to '$var'"
    fi
    
    # this will return true if a variable is unset or set to the empty string ("")
    if [ -z "$VAR" ];    



For in bash::

    for i in $( ls ) ; do
      rm -R $i
    done 



Multiline file creating::

	cat > file <<EOF
	line 1
	line 2
	line 3
	EOF


Make sure only root can run our script::

    if [[ $EUID -ne 0 ]]; then
       echo "This script must be run as root" 1>&2
       exit 1
    fi


    # оба потока будут перенаправлены в файл
    # ls *.txt *.err >file 2>&1
	    >file	# перенаправить стандартный поток вывода (stdout) в файл c именем file
	    2>&1	# перенаправить стандартный поток ошибок (2) в стандартный поток вывода (1).
			    Но, так как стандартный поток вывода уже перенаправлен в файл, то и стандартный поток ошибок перенаправляется туда же.


    # поток вывода будет направлен в файл, а поток ошибок — в терминал
    # ls *.txt *.err 2>&1 >file
	    2>&1	# перенаправить стандартный поток ошибок в стандартный поток вывода.
			    На этот момент поток вывода (1) направляется в терминал, а значит, что поток ошибок тоже перенаправится в терминал.
	    >file	# перенаправить стандартный поток вывода (stdout) в файл c именем file


    # потоки вывода stderr и stdout как будто меняются местами — поток 1 идет в stderr, а поток 2 идет в stdout
    # cat file 3>&2 2>&1 1>&3
	    3>&2	# поток вывода 3 перенаправить туда же, куда выводится поток вывода 2 — в stderr
	    2>&1	# поток вывода 2 перенаправить туда же, куда выводится поток 1 — в stdout
	    1>&3	# поток вывода 1 перенаправить туда же, куда выводится поток 3 — в stderr


Прведу список логических операторв, которые используются для конструкции if-then-else-fi::

    -z # строка пуста
    -n # строка не пуста
    =, (==) # строки равны
    != # строки неравны
    -eq # равно
    -ne # неравно
    -lt,(< ) # меньше
    -le,(<=) # меньше или равно
    -gt,(>) #больше
    -ge,(>=) #больше или равно
    ! #отрицание логического выражения
    -a,(&&) #логическое «И»
    -o,(||) # логическое «ИЛИ»


http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html

-e file	# True if file exists.
-d file	# True if file exists and is a directory.



https://www.opennet.ru/docs/RUS/bash/bash-4.html





set
---

 ``set [abefhkmnptuvxldCHP] [-o опция] [аргумент]``::
 
     
    -a | allexport	отмечает переменные, которые модифицированы или созданы для зкспорта.

    -b | notify	вызывает прекращение фоновых заданий, о котором сообщает перед выводом следующего базового приглашения.

    -е | errexit немедленный выход, если выходное состояние команды ненулевое.

    -f | noglob	выключает генерацию имени файла (глоббирование).

    -h	обнаруживает и запоминает (хеширует) команды как определенные функции до того, как функция будет выполнена.

    -к	В окружении команды располагаются все аргументы ключевых слов, не только те, которые предшествуют имени команды.

    -m | monitor	Разрешается управление заданиями (см. главу 5).

    -n | noexec	Читает команды, но не выполняет их.

    -о имя_опции	Устанавливает флаг, соответствующий имени_опции.

    braceexpand	оболочка должна выполнить brace-расширение (см. раздел 2.2).

    emacs	использует интерфейс редактирования emacs (см. главу 7 "Редактирование командной строки").


    ignoreeof	оболочка не выходит при чтении EOF.

    interactive-comments	позволяет вызывать слово, начинающееся с '#', и все оставшиеся символы на этой строке игнорировать в диа логовой оболочке.

    posix	изменяет режим Bash в соответствии со стандартом Posix 1003.2, когда операция по умолчанию отличается от него. Предназначен для того, чтобы сделать режим строго подчиненным зтому стандарту.

    vi	использует интерфейс редактирования строки редактора vi.

    -p | privileged	Включает привилегированный режим. В зтом режиме файл $ENV не выполняется, и функции оболочки не наследуются из среды. Зто включается автоматически начальными действиями, если идентификатор зффективного пользователя (группы) не равен идентификатору реального пользователя (группы). Выключение зтой опции присваивает идентификатор зффективного пользователя (группы) идентификатору реального пользователя (группы).

    -t	выход после чтения и выполнения команды.

    -u | nounset	во время замещения рассматривает незаданную переменную как ошибку.

    -v | verbose	выдает строки ввода оболочки по мере их считывания.

    -x | xtrace	выводит команды и их аргументы по мере выполнения команд.

    -l	сохраняет и восстанавливает связывание имени в команде for.

    -d | nohash	Выключает хеширование команд, найденных для выполнения. Обычно команды запоминаются в хеш-таблице и, будучи однажды найденными, больше не ищутся.

    -С | noclobber не позволяет существующим файлам перенаправление вывода.

    -Н | histexpand	закрывает замену стиля ! истории. Этот флаг принимается по умолчанию.

    -Р | physical	Если установлена, не следует символьному указателю при выполнении команды типа cd, которая изменяет текущий каталог. Вместо этого используется физический каталог.

    --	Если нет аргументов, следующих за зтим флагом, то не задаются позиционные параметры. В противном случае позиционные параметры присваиваются аргументам, даже если некоторые из них начинаются с а-.

    -	Сигнал конца опции, вызывающей присваивание оставшихся аргументов позиционным параметрам. Опции -x и -v выключаются. Если здесь нет аргументов, позиционный параметр не изменяется.

    При использовании + вместо - осуществляется выключение зтих флагов. Флаги также могут использоваться при вызове оболочки. Текущий набор флагов можно найти в $-. Оставшиеся N переменных - позиционные параметры и присваиваются по порядку $1, $2,...,$N. Если аргументы не даны, выводятся все переменные оболочки.
